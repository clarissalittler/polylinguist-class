# Discussion Prompts

Thought-provoking questions to spark deep thinking about programming paradigms.

## General Paradigm Questions

### The Big Questions

1. **"Is there One True paradigm?"**
   - Or do different problems call for different approaches?
   - When have you seen a paradigm choice make or break a project?

2. **"Should beginners learn one language deeply or many shallowly?"**
   - What did you experience in this course?
   - How has polyglot exposure changed your thinking?

3. **"Do syntax differences matter, or are all languages basically the same?"**
   - What surprised you most about language differences?
   - Where did syntax obscure or reveal the underlying concepts?

---

## Lesson-Specific Discussions

### Lesson 1: Hello World

**"Why do some languages compile and others interpret?"**
- What are the real-world implications?
- Is compilation always faster? Always better?

**"Which 'Hello, World!' felt most natural? Why?"**
- Was it familiarity or actual design?
- What makes a language feel "friendly"?

### Lesson 2: Variables and Types

**"Static typing: helpful guardrails or unnecessary bureaucracy?"**
- Share experiences with type errors
- When did types catch bugs? When did they slow you down?

**"Is mutability a feature or a bug?"**
- When is mutation necessary?
- Can you write real programs without it?

### Lesson 3: Control Flow

**"Are loops or recursion more 'natural' for repetition?"**
- Which did you find easier to think about?
- Are there problems better suited to each?

**"Pattern matching vs if/else: is it just syntax sugar?"**
- What can pattern matching express that if/else can't?
- Is the additional complexity worth it?

### Lesson 4: Functions

**"Should all functions be pure?"**
- What's lost without side effects?
- How do pure functional languages handle I/O?

**"Are closures intuitive or confusing?"**
- When did closures finally "click" for you?
- Real-world examples where closures shine?

### Lesson 5: Data Structures

**"Immutability: elegant theory or practical reality?"**
- Can you build real systems with immutable data?
- What's the performance cost?

**"Does Rust's ownership model solve real problems or create new ones?"**
- Compare your experience with Python vs Rust
- Is compile-time safety worth the effort?

---

## Compare and Contrast

### Pair Discussions

**Python vs Haskell:**
- How do they approach the same problem differently?
- Which is more "powerful"? More "practical"?

**JavaScript vs Java:**
- Both have "Java" in the name - are they similar?
- Dynamic vs static: which caught more bugs?

**C vs Rust:**
- Both systems languages - why choose Rust?
- Is memory safety worth the learning curve?

**Racket vs Prolog:**
- Both unusual paradigms - which was harder?
- When would you actually use each?

---

## Real-World Application

**"If you were building [X], which language would you choose?"**

Fill in X with:
- A web server
- A machine learning model
- A command-line tool
- An operating system
- A mobile app
- A financial trading system
- A game

**Questions to probe:**
- Why that language?
- What paradigm benefits you?
- What are you trading off?

---

## Reflection Prompts

### Mid-Course Check-in

1. Which language surprised you most? Why?
2. Which concept was hardest to grasp?
3. How has your definition of "programming" changed?
4. Can you see yourself using multiple paradigms in one project?

### End-of-Course Reflection

1. If you could only keep 3 of the 9 languages, which and why?
2. What paradigm do you want to explore deeper?
3. How will this change how you approach new languages?
4. What's one thing you'll take to every language you use?

---

## Debate Topics

**Structured Debates (split class):**

1. **"Types should be inferred, not declared"**
   - For: Haskell team
   - Against: Java team

2. **"Mutability is necessary for practical programming"**
   - For: Python team
   - Against: Haskell team

3. **"Functional programming is the future"**
   - For: FP advocates
   - Against: OOP advocates

4. **"Beginners should start with Python, not Haskell"**
   - For: Python advocates
   - Against: FP advocates

---

## Quick Check-in Questions

Use these for beginning of class:

- "What was the most confusing thing from last lesson?"
- "What clicked for you this week?"
- "Share one 'aha!' moment from the exercises"
- "What pattern did you notice across languages?"
- "Which exercise was most valuable? Least valuable?"

---

## Advanced Discussions

### For Advanced Students

**Type Theory:**
- "What is a type, really?"
- "Are Haskell's type classes like interfaces?"
- "How do dependent types differ from regular types?"

**Memory Management:**
- "Is garbage collection always a win?"
- "How does Rust's ownership compare to GC?"
- "When would you choose manual memory management?"

**Paradigm Purity:**
- "Can you mix paradigms in one program?"
- "Is multi-paradigm better or worse than pure paradigm?"
- "JavaScript allows everything - is this good?"

---

Remember: The goal is to think deeply about *why* languages differ, not just *how* they differ.
