# Grading Rubrics

Comprehensive rubrics for assessing student work in the Polyglot Programming course.

## Philosophy

**This course emphasizes:**
- **Understanding over completion**: Better to deeply understand 3 languages than superficially know 9
- **Concept transfer**: Can students apply ideas across languages?
- **Growth mindset**: Improvement matters more than initial perfection
- **Process over product**: Did they think critically and experiment?

---

## Exercise Grading Rubric

### Individual Exercise Assessment (10 points)

| Criteria | Excellent (9-10) | Good (7-8) | Satisfactory (5-6) | Needs Work (0-4) |
|----------|------------------|------------|-------------------|------------------|
| **Correctness** (3 pts) | Code runs perfectly, handles edge cases | Code works for main cases, minor issues | Code partially works, some bugs | Code doesn't run or has major errors |
| **Understanding** (4 pts) | Clear understanding of concepts, can explain why | Understands main concepts, some gaps | Basic understanding, confused on details | Doesn't understand underlying concepts |
| **Code Quality** (2 pts) | Clean, readable, idiomatic for the language | Mostly clean, few style issues | Works but messy or non-idiomatic | Very messy or confusing code |
| **Exploration** (1 pt) | Tried multiple approaches or languages | Completed as specified | Minimal effort beyond requirements | Incomplete or no experimentation |

**Grading notes:**
- **Focus on effort and understanding**, not perfection
- **Partial credit** for working code with bugs
- **Bonus points** for creative solutions or going beyond requirements

### Exercise Portfolio Assessment

Instead of grading every exercise individually, consider portfolio assessment:

**Portfolio Requirements:**
- Complete 70% of exercises across all lessons
- Submit 3 "best" exercises with explanations
- Reflection: What did you learn? What was challenging?

**Grading:**
- **Completeness** (30%): Did they attempt enough exercises?
- **Quality** (40%): How well done are the submitted best 3?
- **Reflection** (30%): Did they think critically about the experience?

---

## Project Grading Rubric

### Small Projects (25 points)

| Criteria | Points | Excellent | Good | Satisfactory | Needs Work |
|----------|--------|-----------|------|--------------|------------|
| **Functionality** | 10 | All features work perfectly | Most features work | Some features work | Doesn't work |
| **Multi-language** | 5 | Uses 3+ languages appropriately | Uses 2 languages | Single language | No comparison |
| **Code Quality** | 5 | Clean, well-organized, commented | Mostly clean | Works but messy | Very messy |
| **Documentation** | 3 | Excellent README, clear explanation | Good README | Basic documentation | No documentation |
| **Learning** | 2 | Clear growth, tried new things | Some learning evident | Minimal growth | No evidence of learning |

### Large Projects (50 points)

| Criteria | Points | Description |
|----------|--------|-------------|
| **Functionality** | 20 | Does the project work as specified? |
| **Architecture** | 10 | Well-structured? Appropriate design? |
| **Multi-paradigm** | 10 | Effective use of different paradigms? |
| **Testing** | 5 | Are there tests? Do they pass? |
| **Documentation** | 3 | Clear README, code comments, usage guide? |
| **Presentation** | 2 | Can you explain it clearly? |

**Specific Criteria:**

**Functionality (20 pts):**
- 20: All features work perfectly, handles edge cases
- 15: Main features work, minor bugs
- 10: Core functionality works, missing some features
- 5: Partially working, significant issues
- 0: Doesn't run

**Architecture (10 pts):**
- 10: Excellent design, clear separation of concerns
- 7-8: Good structure, minor organizational issues
- 5-6: Works but poor organization
- 2-4: Confusing or ad-hoc structure
- 0: No apparent architecture

**Multi-paradigm (10 pts):**
- 10: Uses 3+ paradigms effectively and appropriately
- 7-8: Uses 2 paradigms well
- 5-6: Attempts multiple paradigms but awkwardly
- 2-4: Mostly single paradigm
- 0: No paradigm awareness

---

## Participation Rubric (Optional)

For courses with in-class components:

| Activity | Points | Description |
|----------|--------|-------------|
| **Attendance** | 20 | Present and engaged (2 pts per class) |
| **Discussion** | 30 | Contributes thoughtfully to paradigm discussions |
| **Pair Programming** | 20 | Works well with others, shares knowledge |
| **Code Reviews** | 20 | Provides constructive feedback on peer code |
| **Growth** | 10 | Shows improvement and learning over time |

---

## Quiz/Exam Rubric

### Concept Questions (per question)

**Sample question**: "Explain the difference between mutable and immutable data structures. Give examples from two languages."

| Points | Description |
|--------|-------------|
| 5 | Complete, accurate explanation with correct examples from 2 languages |
| 4 | Good explanation, examples from 1-2 languages with minor errors |
| 3 | Basic understanding, incomplete or partially incorrect |
| 2 | Shows some understanding but significant gaps |
| 0-1 | Incorrect or no answer |

### Coding Questions (per question)

**Sample question**: "Write a function in Python and Haskell that returns the sum of a list."

| Points | Description |
|--------|-------------|
| 10 | Both versions correct, idiomatic, well-written |
| 8-9 | Both mostly correct, minor syntax errors |
| 6-7 | One correct, other attempted with errors |
| 4-5 | Both attempted, significant errors |
| 2-3 | One attempted, other missing |
| 0-1 | Minimal or no attempt |

### Comparison Questions (per question)

**Sample question**: "Compare how Python and Haskell handle loops. Which approach is more appropriate when?"

| Points | Description |
|--------|-------------|
| 10 | Excellent comparison, nuanced understanding, good examples |
| 8-9 | Good comparison, understands main differences |
| 6-7 | Basic comparison, some understanding |
| 4-5 | Superficial comparison, gaps in understanding |
| 0-3 | Poor or no comparison |

---

## Final Course Grade Breakdown (Suggested)

### Option 1: Exercise-Heavy

- Exercises & Practice (50%)
- Projects (30%)
- Final Exam/Project (20%)

### Option 2: Project-Heavy

- Projects (50%)
- Exercises (25%)
- Final Exam/Project (25%)

### Option 3: Balanced

- Exercises (30%)
- Projects (40%)
- Participation (10%)
- Final Exam/Project (20%)

---

## Assignment-Specific Rubrics

### Lesson 1 Exercises (Sample)

**Exercise: "Customize Your Greeting"**

| Points | Criteria |
|--------|----------|
| 2 | Successfully runs in Python |
| 2 | Successfully runs in JavaScript |
| 2 | Successfully runs in one compiled language |
| 2 | Proper file structure and naming |
| 2 | Can explain compilation vs interpretation |

### Lesson 4 Exercises (Sample)

**Exercise: "Function Composition"**

| Points | Criteria |
|--------|----------|
| 3 | Compose function works correctly |
| 3 | Demonstrates understanding of closures |
| 2 | Implemented in 2+ languages |
| 2 | Code is clean and readable |

---

## Self-Assessment Rubric (for students)

Encourage students to self-assess using this rubric:

### Per Lesson Self-Check

**I can... (check all that apply)**

- [ ] Explain the main concepts in my own words
- [ ] Write simple programs demonstrating the concepts
- [ ] Implement the concepts in at least 2 languages
- [ ] Compare how different languages handle the concepts
- [ ] Identify when to use each approach

**My confidence level:** (1-5 scale)
- Understanding concepts: ___/5
- Writing code: ___/5
- Explaining to others: ___/5

**What I'm still confused about:**
_____________________

**What I want to explore further:**
_____________________

---

## Rubric Usage Tips

### For Objective Assessment

1. **Be consistent**: Use same rubric for all students
2. **Provide feedback**: Don't just give points, explain why
3. **Show examples**: Share exemplary work (with permission)
4. **Allow revision**: Let students improve based on feedback

### For Formative Assessment

1. **Use rubrics as learning tools**: Share with students before assignment
2. **Self-assessment first**: Have students grade themselves
3. **Peer review**: Students assess each other's work
4. **Growth tracking**: Compare early vs late work

### Common Pitfalls to Avoid

- ❌ Grading only on "correct answer"
- ❌ Expecting mastery of all 9 languages
- ❌ Not giving partial credit
- ❌ Focusing only on syntax, not concepts
- ❌ Penalizing creative solutions
- ❌ Not considering learning process

### What to Reward

- ✅ Clear understanding of paradigm differences
- ✅ Good code comments and documentation
- ✅ Asking thoughtful questions
- ✅ Experimenting beyond requirements
- ✅ Helping other students
- ✅ Recognizing when to use each language

---

## Alternative Assessment Approaches

### Contract Grading

Students contract for grade by completing specified work:

**For an A:**
- Complete 90% of exercises
- 2 large projects or 4 small projects
- Active participation
- Final exam or reflection essay

**For a B:**
- Complete 75% of exercises
- 1 large project or 3 small projects
- Regular participation
- Final exam or reflection essay

### Specifications Grading

Assignments are either "satisfactory" or "not yet":
- Clear specifications for each assignment
- Must meet all specs for "satisfactory"
- Can resubmit until satisfactory
- Grade based on number of satisfactory assignments

### Portfolio Grading

Students curate portfolio showing:
- Best code examples (3-5)
- Reflection on learning
- Comparison of paradigms
- Creative application of concepts

Graded holistically on demonstrated growth and understanding.

---

## Feedback Templates

### Encouraging Feedback

> "Great work on this exercise! I can see you really understand [concept]. Your code in [language] is particularly clean. For next time, consider how [language2] might handle this differently."

### Constructive Feedback

> "I see you're working hard on this. Your logic is close, but there's a misunderstanding about [concept]. Let's review the example in Lesson X. Try running your code line by line to see where it diverges from expected output."

### Growth-Oriented Feedback

> "Comparing your Lesson 1 work to this shows real growth! You're now writing much more idiomatic [language] code. Keep focusing on understanding the 'why' behind each paradigm's approach."

---

Remember: The goal is to develop paradigm-fluent programmers who can learn any language, not to create experts in all 9 languages!
