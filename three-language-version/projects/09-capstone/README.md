# Project 9: Capstone

**Quarter 3, Weeks 8-11**
**Prerequisites:** All previous lessons and projects
**Weight:** 15% of final grade (double the other projects)

---

## The Big Idea

This is YOUR project. Build something that demonstrates everything you've learned—across languages, paradigms, and concepts. Make something you're proud of.

The capstone is your chance to integrate your learning and create something meaningful.

---

## Overview

The capstone is **not a prescribed project**. You propose what you want to build, get feedback, and execute your vision.

### Timeline
- **Week 8**: Proposal due, feedback session
- **Week 9**: Development, check-in #1
- **Week 10**: Development, check-in #2
- **Week 11**: Final presentation at course showcase

### Requirements
1. **Proposal** (due Week 8)
2. **Working project** (due Week 11)
3. **Presentation** (Week 11 showcase)
4. **Reflection** (due with project)

---

## Three Capstone Paths

Choose the path that excites you:

### Path A: Build Something Ambitious

Create a substantial project that integrates concepts from across the course.

**Examples:**
- A complete game with AI opponents
- A compiler or interpreter for a language you design
- A data analysis tool with visualization
- A simulation with emergent behavior
- A creative tool that others can use
- A web scraper + analyzer + visualizer pipeline

**Requirements:**
- Significant scope (40+ hours of work)
- Demonstrates multiple course concepts
- Working, polished result
- Clear documentation

---

### Path B: Deep Exploration

Research a topic deeply and teach others through documentation and examples.

**Examples:**
- "Functional Programming Patterns Compared: Haskell, Racket, and Python"
- "Building a Database: From B-Trees to Query Optimization"
- "Type Systems: What Haskell Knows That Python Doesn't"
- "Memory Management: Manual, Garbage Collected, and Ownership"
- "Parsing Techniques: Recursive Descent to Parser Combinators"

**Requirements:**
- Substantial written component (3000+ words)
- Code examples in multiple languages
- Teaching materials (tutorials, exercises)
- Demonstrates deep understanding

---

### Path C: Minor Language Showcase

Build a significant project in one of the minor languages (Racket, C, Rust, or Prolog).

**Examples:**
- Racket: A domain-specific language with macros
- C: A memory allocator or simple OS component
- Rust: A concurrent data structure or systems tool
- Prolog: A logical inference engine or puzzle solver

**Requirements:**
- Substantial project in minor language
- Comparative analysis with core languages
- Reflection on paradigm strengths/weaknesses
- Working, documented code

---

## Proposal Requirements

Submit by **Week 8** (1-2 pages):

### 1. Project Description
- What are you building?
- What problem does it solve?
- Why does it interest you?

### 2. Path Selection
- Which path (A, B, or C)?
- Why is this the right choice for you?

### 3. Scope & Milestones
- What are the core features (must-have)?
- What are stretch goals (nice-to-have)?
- Week-by-week plan

### 4. Technical Approach
- What languages will you use?
- What concepts from the course apply?
- What will be challenging?

### 5. Success Criteria
- How will you know you succeeded?
- What does "done" look like?

---

## Proposal Example

```markdown
# Capstone Proposal: Chess Engine with AI

## Project Description
I want to build a chess engine that can play against humans
with adjustable difficulty levels. The engine will evaluate
positions, generate legal moves, and use minimax with
alpha-beta pruning to select moves.

## Path Selection
Path A: Build Something Ambitious

I love chess and want to understand how computers "think"
about the game. This project combines data structures (game
tree), algorithms (minimax, evaluation), and software design.

## Scope & Milestones

### Core Features (Must-Have)
- Board representation and move generation
- Legal move validation
- Basic position evaluation
- Minimax AI with depth limit
- Simple text-based interface

### Stretch Goals
- Alpha-beta pruning
- Opening book
- Adjustable difficulty
- Move history and undo
- ASCII board visualization

### Week-by-Week Plan
- Week 8: Board representation, move generation
- Week 9: Basic AI (minimax), text interface
- Week 10: Evaluation function tuning, alpha-beta
- Week 11: Polish, documentation, presentation

## Technical Approach

Primary language: Python (for rapid development)
Secondary: Haskell (for comparison of recursive evaluation)

Course concepts:
- Recursion (minimax is naturally recursive)
- Data structures (game tree, move lists)
- Algorithm analysis (branching factor, depth)
- OOP (piece classes, board class)

Challenges:
- Move generation for all pieces correctly
- Efficient board representation
- Tuning evaluation function

## Success Criteria
- Can play a complete game without crashing
- AI makes reasonable moves (not random)
- Beats a beginner human player
- Code is clean and documented
```

---

## Assessment

The capstone uses the standard five dimensions with higher expectations:

| Dimension | Weight | Capstone Expectations |
|-----------|--------|----------------------|
| Creativity & Ambition | 30% | Substantial scope, personal vision, risk-taking |
| Functionality | 25% | Working software, polished result |
| Code Quality | 15% | Clean, well-organized, professional |
| Process | 15% | Regular progress, iteration, version control |
| Reflection | 15% | Deep insights, honest assessment |

### Grading Guidance

**A/A+**: Impressive scope, working beautifully, demonstrates mastery
**A-/B+**: Solid project, mostly working, demonstrates competence
**B/B-**: Adequate scope, partially working, shows effort
**C**: Minimal scope or incomplete, but shows understanding
**Below C**: Incomplete or missing significant components

---

## Check-ins

### Week 9 Check-in
- Show progress on core features
- Discuss challenges and blockers
- Adjust scope if needed

### Week 10 Check-in
- Demo current state
- Plan for final push
- Prepare for presentation

Check-ins are not graded but are required. They help ensure you succeed.

---

## Final Presentation

**15-20 minutes** at the course showcase:

1. **Introduction** (2-3 min)
   - What did you build?
   - Why did you choose this?

2. **Demo** (5-8 min)
   - Show it working
   - Highlight key features
   - Don't hide bugs—explain them

3. **Technical Deep-Dive** (3-5 min)
   - Interesting code or algorithms
   - Challenges you solved
   - What you're proud of

4. **Reflection** (3-5 min)
   - What did you learn?
   - What would you do differently?
   - What's next for this project?

5. **Q&A** (2-3 min)

---

## Reflection Questions

Answer in your `REFLECTION.md`:

1. **What did you create and why?** What drew you to this project?

2. **What are you most proud of?** Technical achievement, design, persistence?

3. **What was the biggest challenge?** How did you overcome it?

4. **What would you do differently?** With more time? Starting over?

5. **What concepts from the course were most relevant?** How did they help?

6. **How did using multiple languages/paradigms influence your thinking?**

7. **What did you learn about yourself as a programmer?**

8. **Where does this project go from here?** Will you continue it?

---

## Tips for Success

### Start Strong
The proposal matters. A clear vision makes execution easier.

### Scope Wisely
Better to do something smaller well than something huge poorly.
Have a minimum viable version that you KNOW you can complete.

### Work Consistently
4 hours/day for 3 weeks beats 40 hours in the last 3 days.

### Ask for Help
Office hours exist. Use them. Getting stuck alone helps no one.

### Document As You Go
Don't leave reflection until the end. Keep notes throughout.

### Test Your Demo
Practice your presentation. Make sure the demo works.

### Be Honest
Bugs happen. Scope changes. That's real software development.
Own it in your reflection.

---

## Submission Checklist

### Week 8
- [ ] Proposal submitted
- [ ] Feedback incorporated

### Week 11
- [ ] Working project code
- [ ] README with setup/run instructions
- [ ] REFLECTION.md (detailed)
- [ ] Git history showing development
- [ ] Presentation ready
- [ ] Demo tested and working

---

## Final Thoughts

This is the culmination of three quarters of learning:
- You've written code in Python, C++, Haskell
- You've explored Racket, C, Rust, Prolog
- You've built projects, analyzed algorithms, implemented data structures
- You've learned to think about programming, not just write code

Now show us what you can do.

**Make something you're proud of. Something that shows who you've become as a programmer.**

---

**Good luck. We can't wait to see what you build!**
