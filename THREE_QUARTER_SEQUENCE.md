# Three-Quarter Polyglot Programming Sequence

A comprehensive three-quarter curriculum teaching computer science through multiple programming languages and paradigms. Each quarter builds on the previous, deepening understanding while introducing new concepts and languages.

## Overview

### Quarter 1: Foundations - Introduction to Programming
**Focus:** Core programming concepts, basic paradigms, computational thinking
**Languages:** Python, JavaScript, C, Java, Ruby, Haskell, Racket, Prolog, Rust (9 languages)
**Level:** Beginner (no prerequisites)

### Quarter 2: Intermediate - Paradigm Mastery and Advanced Concepts
**Focus:** Deep paradigm exploration, advanced features, design patterns, concurrency
**Languages:** Same 9 languages - developing depth and fluency
**Level:** Intermediate (Quarter 1 or equivalent)

### Quarter 3: Advanced - Language Implementation and Real Systems
**Focus:** Compiler/interpreter construction, performance, multi-language integration, mastery
**Languages:** Same 9 languages - achieving expertise and building substantial systems
**Level:** Advanced (Quarter 2 or equivalent)

**Philosophy:** Rather than adding breadth with new languages, this sequence builds deep expertise in 9 carefully-chosen languages representing all major paradigms. By Quarter 3, students are truly fluent in multiple paradigms and can leverage each language's unique strengths. With 9 languages instead of 10, students have more time to achieve true mastery in each.

---

# Quarter 1: Foundations - Introduction to Programming

## Course Description

Learn programming fundamentals through 9 different languages representing procedural, object-oriented, functional, and logic paradigms. Understand how the same concepts manifest differently across paradigms.

## Learning Objectives

By the end of Quarter 1, students will:
- Write programs in at least 5 different programming languages
- Understand fundamental CS concepts: variables, functions, control flow, recursion
- Explain differences between programming paradigms
- Choose appropriate data structures for problems
- Read and understand code in unfamiliar languages
- Debug programs using different language tools

## Weekly Schedule (10 weeks)

### Week 1: Hello, World! & Development Environments
**Concepts:** Compilation vs interpretation, REPLs, basic syntax, comments
**Languages:** All 10 languages
**Topics:**
- First programs in each language
- Understanding error messages
- Using documentation
- REPL-driven development

**Lab:** Write "Hello, World!" in all 10 languages, create personalized greetings

**Deliverable:** Personal greeting program in 3 chosen languages

---

### Week 2: Variables, Types, and Type Systems
**Concepts:** Static vs dynamic typing, type inference, strong vs weak typing
**Languages:** Python, JavaScript, C, Java, Haskell, OCaml, Rust
**Topics:**
- Primitive types across languages
- Type annotations and inference
- Type errors at compile-time vs runtime
- Mutability and immutability

**Lab:** Type system exploration - cause type errors intentionally, fix them

**Deliverable:** Comparison essay on static vs dynamic typing (2 pages)

---

### Week 3: Control Flow and Boolean Logic
**Concepts:** Conditionals, loops, short-circuit evaluation, truthiness
**Languages:** Python, C, Ruby, JavaScript, Haskell, Rust
**Topics:**
- If/else, switch/case/pattern matching
- For loops, while loops, and recursion as alternatives
- Boolean operators and truthiness differences
- Guard clauses and early returns

**Lab:** Implement FizzBuzz in 5 languages

**Deliverable:** Control flow comparison chart + FizzBuzz implementations

---

### Week 4: Functions and Scope
**Concepts:** Function definition, parameters, return values, scope, closures
**Languages:** Python, JavaScript, Haskell, C, Ruby, OCaml
**Topics:**
- Pure vs impure functions
- Function signatures and type annotations
- Lexical scope and closures
- First-class functions
- Recursion basics

**Lab:** Implement factorial (iterative and recursive) in multiple languages

**Deliverable:** Function implementations demonstrating scope and closure

---

### Week 5: Data Structures I - Collections
**Concepts:** Arrays, lists, tuples, sets, dictionaries/maps
**Languages:** Python, Java, Haskell, JavaScript, OCaml, Rust
**Topics:**
- Mutable vs immutable collections
- List operations: map, filter, indexing
- Hash tables/dictionaries
- Array bounds and safety
- Collection iteration patterns

**Lab:** Implement a contact manager using appropriate data structures

**Deliverable:** Contact manager in 2 languages (one functional, one imperative)

---

### Week 6: Recursion and Recursive Data Structures
**Concepts:** Recursive thinking, base cases, tail recursion, trees, lists
**Languages:** Haskell, Racket, OCaml, Python, Rust
**Topics:**
- Understanding recursion through visualization
- Tail call optimization
- Recursive data structures (linked lists, trees)
- Recursion vs iteration tradeoffs
- Stack overflow and limits

**Lab:** Implement tree traversal, recursive list operations

**Deliverable:** Binary tree implementation with traversals in 2 languages

---

### Week 7: Higher-Order Functions and Functional Patterns
**Concepts:** Functions as first-class values, map/filter/reduce, composition
**Languages:** Haskell, JavaScript, Python, Ruby, OCaml, Racket
**Topics:**
- Passing functions as arguments
- Returning functions (currying, partial application)
- Map, filter, reduce/fold patterns
- Function composition and pipelines
- List comprehensions vs higher-order functions

**Lab:** Data transformation pipeline using functional techniques

**Deliverable:** Data processing program using map/filter/reduce

---

### Week 8: Object-Oriented Programming
**Concepts:** Classes, objects, inheritance, encapsulation, polymorphism
**Languages:** Java, Ruby, Python, JavaScript (ES6 classes)
**Topics:**
- Class definition and instantiation
- Attributes and methods
- Inheritance vs composition
- Polymorphism and interfaces
- OOP vs functional approaches to state

**Lab:** Design a simple game (e.g., text adventure) using OOP

**Deliverable:** OOP design document + implementation in 2 languages

---

### Week 9: Pattern Matching and Algebraic Data Types
**Concepts:** Pattern matching, algebraic data types, tagged unions
**Languages:** Haskell, OCaml, Rust, Prolog, Racket
**Topics:**
- Pattern matching syntax
- Algebraic data types (sum and product types)
- Option/Maybe types
- Pattern exhaustiveness
- Destructuring in different languages

**Lab:** Implement expression evaluator using pattern matching

**Deliverable:** Expression evaluator with ADTs in 2 languages

---

### Week 10: Type Systems and Introduction to Logic Programming
**Concepts:** Type inference, generics, parametric polymorphism, logic programming
**Languages:** Haskell, OCaml, Java, TypeScript (preview), Prolog
**Topics:**
- Type inference algorithms
- Generics and parametric types
- Type classes and traits
- Introduction to Prolog and declarative thinking
- Unification and backtracking basics

**Lab:** Generic data structures, simple Prolog facts and queries

**Final Project:** Implement the same non-trivial program in 3 languages from different paradigms (procedural, OOP, functional), with written analysis comparing approaches

---

## Assessment

- **Weekly Labs (40%):** Hands-on coding in multiple languages
- **Deliverables (30%):** Written comparisons, implementations
- **Final Project (25%):** Multi-language implementation + analysis
- **Participation (5%):** Discussion, code reviews, peer feedback

---

# Quarter 2: Intermediate - Paradigm Mastery and Advanced Concepts

## Course Description

Deep dive into advanced features of each language and paradigm. Students develop fluency and idiomatic proficiency in the 10 languages from Quarter 1. Focus on paradigm-specific strengths, advanced patterns, and building non-trivial systems.

## Languages (Same 9 from Quarter 1)

Now students go deeper into each language's unique strengths:
- **Haskell, Racket:** Advanced functional programming, type theory, macros
- **Java, Ruby, Python:** Advanced OOP, design patterns, metaprogramming
- **C, Rust:** Systems programming, memory management, performance
- **JavaScript:** Async patterns, event-driven architecture, functional JS
- **Prolog:** Advanced logic programming, constraint solving

## Learning Objectives

By the end of Quarter 2, students will:
- Write idiomatic code in each of the 9 languages
- Master advanced functional programming (functors, monads, lazy evaluation)
- Design and implement complex data structures in multiple paradigms
- Apply design patterns appropriately, understanding paradigm-specific alternatives
- Write concurrent and parallel programs in multiple languages
- Understand and work with different memory management models
- Leverage each language's unique strengths for appropriate problems
- Build multi-component systems using multiple languages together

## Weekly Schedule (10 weeks)

### Week 1: Advanced Functional Programming I - Functors and Applicatives
**Concepts:** Functors, applicative functors, function composition at scale
**Languages:** Haskell (primary), Racket (comparison), Rust (practical application)
**Topics:**
- Functor type class in Haskell
- Mapping over contexts (Option, List, etc.)
- Applicative functors and validation
- Composing effectful computations
- Racket's approach without type classes
- Rust's Iterator trait as practical functor application
- Comparing typed (Haskell) vs untyped (Racket) approaches

**Lab:** Build a validation library in Haskell, compare to approach in Racket and Rust

---

### Week 2: Advanced Functional Programming II - Monads
**Concepts:** Monads, do-notation, monadic composition, error handling
**Languages:** Haskell (primary), Rust (Result/Option), Python (comparison)
**Topics:**
- Understanding the Monad abstraction in Haskell
- Common monads: Maybe, Either, IO, List, State
- Do-notation in Haskell
- Rust's Result and Option as restricted monads
- Python's approach to sequencing operations (context managers, generators)
- Why monads matter: composing computations with effects
- Comparing approaches to error handling across paradigms

**Lab:** Implement a monadic parser combinator library in Haskell, compare error handling approach to Rust

---

### Week 3: Lazy Evaluation and Infinite Data Structures
**Concepts:** Lazy evaluation, thunks, infinite sequences, generators, memoization
**Languages:** Haskell (lazy by default), Python (generators), JavaScript (generators), Rust (iterators)
**Topics:**
- Strict vs lazy evaluation
- Haskell's lazy-by-default model
- Infinite lists and streams in Haskell
- Python generators and yield
- JavaScript generators and iterators
- Rust's lazy iterators (zero-cost abstractions)
- Memoization and dynamic programming
- Space leaks and when to force evaluation
- Comparing lazy evaluation strategies

**Lab:** Solve computational problems using lazy evaluation (Haskell) and generators (Python, JavaScript, Rust)

---

### Week 4: Advanced Data Structures Across Paradigms
**Concepts:** Trees, graphs, heaps, tries, persistent data structures
**Languages:** Java (OOP), Haskell (functional), Rust (ownership), C (manual memory)
**Topics:**
- Balanced trees (AVL, Red-Black) in Java and C
- Persistent trees in Haskell (structural sharing)
- Graph representations and algorithms across languages
- Priority queues and heaps
- Rust's ownership preventing common data structure bugs
- Performance tradeoffs of different implementations

**Lab:** Implement same data structure (e.g., BST or graph) in 3 languages, compare implementations and performance

---

### Week 5: Type Systems Deep Dive
**Concepts:** Advanced types, GADTs, phantom types, type-level programming
**Languages:** Haskell (advanced types), Rust (traits), Java (generics), Python (gradual typing)
**Topics:**
- Generalized algebraic data types (GADTs) in Haskell
- Type families and associated types in Haskell
- Phantom types for type-safety
- Rust's trait system vs Haskell's type classes
- Java's generics and type erasure (limitations)
- Python's gradual typing (type hints) as middle ground
- Comparing expressiveness across type systems

**Lab:** Type-safe embedded DSL using advanced types in Haskell, compare to Rust's type safety and Python's runtime checks

---

### Week 6: Error Handling Idioms Across All Languages
**Concepts:** Exceptions, Result types, Maybe/Option, error monads, error codes
**Languages:** All 9 languages, comparing approaches
**Topics:**
- Exception-based error handling (Java, Python, Ruby, JavaScript)
- C's error codes and errno
- Result and Option types (Rust, Haskell)
- Railway-oriented programming in functional languages
- JavaScript Promises and error handling
- Prolog's failure and backtracking as error handling
- Racket's conditions and restarts
- Comparing safety, ergonomics, and performance

**Lab:** Robust file processing system with comprehensive error handling in 3 languages (one from each paradigm)

---

### Week 7: Design Patterns and Paradigm Alternatives
**Concepts:** GOF patterns, functional alternatives, when patterns indicate language limitations
**Languages:** Java (OOP patterns), Haskell (functional alternatives), Python (both), Rust (traits)
**Topics:**
- Classic OOP patterns: Strategy, Observer, Visitor, Decorator
- Functional alternatives using higher-order functions
- Python's approach (multi-paradigm flexibility)
- Rust's trait objects and enums
- Racket's macros eliminating need for patterns
- When patterns are unnecessary in other paradigms
- Understanding what patterns reveal about language design

**Lab:** Implement same system in Java (using patterns) and Haskell (functional approach), analyze differences

---

### Week 8: Metaprogramming Across Languages
**Concepts:** Code generation, macros, reflection, decorators, compile-time programming
**Languages:** Racket (hygenic macros), Ruby (open classes), Python (decorators/metaclasses), Rust (macros)
**Topics:**
- Racket's powerful macro system and homoiconicity
- Ruby's open classes and metaprogramming
- Python decorators and metaclasses
- Rust's macro_rules! and procedural macros
- Compile-time vs runtime metaprogramming
- Comparing power and safety across approaches
- When metaprogramming helps vs hurts

**Lab:** Create a DSL using macros in Racket, compare to Ruby's metaprogramming and Python's approach

---

### Week 9: Concurrent Programming I - Threads and Shared Memory
**Concepts:** Threads, mutexes, race conditions, deadlock, memory models
**Languages:** Java (threads), Python (GIL limitations), C (pthreads), Rust (safety)
**Topics:**
- Thread creation and management across languages
- Shared memory and synchronization primitives
- Mutexes, semaphores, condition variables
- Race conditions and data races
- Deadlock detection and prevention
- Python's GIL and its implications
- Rust's ownership preventing data races at compile-time
- Memory models and ordering

**Lab:** Thread-safe data structures in multiple languages, see how Rust prevents common bugs

---

### Week 10: Concurrent Programming II - Async and Alternative Models
**Concepts:** Async/await, event loops, futures, immutability for concurrency
**Languages:** JavaScript (event loop), Python (asyncio), Rust (async), Haskell (STM)
**Topics:**
- JavaScript's event loop and async/await
- Python's asyncio and comparison to threads
- Rust's async/await and zero-cost futures
- Haskell's Software Transactional Memory (STM)
- Functional approaches to concurrency (immutability)
- Comparing threads, async, and message passing
- When to use each model

**Lab:** Async I/O server in JavaScript, Python, and Rust - compare approaches and performance

**Final Project:** Multi-language system using at least 3 different languages/paradigms. Examples:
- Web application: Python backend, JavaScript frontend, C extension for performance
- Data pipeline: Haskell for transformations, Python for orchestration, Rust for performance-critical parts
- Interpreter: OCaml/Haskell for parser, C for runtime, Python for tooling
Include architectural documentation explaining language and paradigm choices.

---

## Assessment

- **Weekly Labs (35%):** Advanced implementations
- **Design Exercises (25%):** Architectural decisions, pattern applications
- **Final Project (35%):** Multi-paradigm system with documentation
- **Participation (5%):** Code reviews, design discussions

---

# Quarter 3: Advanced - Language Implementation and Real Systems

## Course Description

Advanced topics in programming language implementation, compiler construction, performance optimization, and building substantial multi-language systems. Students achieve mastery of the 10 languages and understand how languages are implemented. Focus on real-world complexity and production concerns.

## Languages (Same 9 - Now Achieving Mastery)

Students now leverage deep expertise in all 9 languages:
- **Haskell:** Implement type systems, advanced functional design, compiler components
- **Racket:** Language-oriented programming, creating new languages, macro systems
- **C, Rust:** Systems programming, performance optimization, FFI
- **Python, Ruby:** Scripting, glue code, tooling
- **Java:** Enterprise systems, JVM ecosystem
- **JavaScript:** Web interfaces, Node.js tooling
- **Prolog:** Logic-based DSLs, constraint solving

## Learning Objectives

By the end of Quarter 3, students will:
- Achieve fluency and expertise in all 9 languages
- Implement a complete programming language (lexer, parser, interpreter/compiler)
- Understand low-level memory management and optimize for performance
- Build systems integrating multiple languages via FFI
- Write production-quality concurrent and parallel programs
- Profile and optimize code in multiple languages
- Make informed language and paradigm choices based on deep understanding
- Contribute to real open-source projects in multiple languages

## Weekly Schedule (10 weeks)

### Week 1: Memory Management Deep Dive
**Concepts:** Stack vs heap, manual management, GC algorithms, ownership, FFI
**Languages:** C (manual), Rust (ownership), Java (GC), Python (reference counting + GC), Haskell (GC)
**Topics:**
- Memory layout and allocation strategies
- Manual memory management in C (malloc/free)
- Garbage collection algorithms (mark-sweep, generational)
- Reference counting in Python
- Rust's ownership and borrow checker
- Memory leaks and use-after-free bugs
- Comparing memory overhead and performance
- FFI between languages (calling C from Python/Ruby/Haskell)

**Lab:** Implement same program in C (manual), Rust (ownership), and Python (GC) - analyze memory usage and performance

---

### Week 2: Performance Analysis and Optimization
**Concepts:** Profiling, algorithmic complexity, micro-optimizations, benchmarking
**Languages:** Python (baseline), C (optimized), Rust (safe+fast), Java (JIT), Haskell (lazy)
**Topics:**
- Profiling tools for each language (cProfile, valgrind, perf, criterion)
- Algorithmic vs constant-factor optimization
- Understanding JIT compilation (Java)
- Lazy evaluation performance characteristics (Haskell)
- Cache-friendly code and memory locality
- Comparing languages for same algorithm
- When to optimize, when to prioritize clarity
- Benchmarking methodology and pitfalls

**Lab:** Implement computationally intensive algorithm in 5 languages, profile and optimize each, compare results

---

### Week 3: Language Implementation I - Lexing and Parsing
**Concepts:** Lexical analysis, parsing, grammars, ASTs, parser generators
**Languages:** Haskell (parser combinators), Python (PLY), Racket (syntax objects), Rust (nom)
**Topics:**
- Regular expressions and lexing
- Context-free grammars
- Parser combinators in Haskell (Parsec/Megaparsec)
- Recursive descent parsing by hand
- Using parser generators (Python PLY)
- Parser combinators in Rust (nom)
- Building and manipulating ASTs
- Error recovery and reporting
- Racket's syntax objects and reader macros

**Lab:** Build lexer and parser for a small language in Haskell (combinators) and Python (generator), compare approaches

---

### Week 4: Language Implementation II - Interpretation and Compilation
**Concepts:** Tree-walking interpreters, environments, closures, bytecode VMs
**Languages:** Haskell (tree-walking interpreter), Python (studying CPython), C (VM), Rust (safe implementation)
**Topics:**
- Tree-walking interpretation in Haskell
- Environment and closure implementation
- Implementing functions and scope
- Bytecode design (study Python bytecode)
- Stack-based virtual machines
- Implementing VM in C for performance
- Garbage collection for your language
- Rust for safe language implementation (memory safety without GC)

**Lab:** Extend interpreter from Week 3 with functions, closures, and scope in Haskell. Optionally implement bytecode compiler and VM in C or Rust

---

### Week 5: Type Systems and Type Inference Implementation
**Concepts:** Hindley-Milner, unification, type checking, polymorphism
**Languages:** Haskell (implementing type system and reference), Rust (type system study), Python (type hints)
**Topics:**
- Algorithm W (Hindley-Milner inference) implemented in Haskell
- Unification algorithm implementation
- Type environments and substitution
- Let-polymorphism
- Type inference vs type checking
- Implementing generics/parametric polymorphism
- Studying Rust's type system design
- Python's gradual typing as comparison
- Error messages for type errors

**Lab:** Implement Hindley-Milner type inference in Haskell for your language from previous weeks

---

### Week 6: Parallel Programming and Performance
**Concepts:** Parallelism vs concurrency, data parallelism, work stealing, SIMD
**Languages:** Rust (rayon), Java (Fork/Join), Python (multiprocessing), C (OpenMP), Haskell (par/seq)
**Topics:**
- Parallelism vs concurrency fundamentals
- Data parallelism and map-reduce
- Python's multiprocessing vs threading (GIL)
- Rust's rayon for data parallelism
- Java's Fork/Join framework
- OpenMP pragmas in C
- Haskell's par and pseq for pure parallelism
- Work-stealing schedulers
- Measuring parallel speedup

**Lab:** Parallel data processing in 4 languages, measure speedup, analyze overhead

---

### Week 7: Advanced Concurrency: Atomics and Lock-Free Programming
**Concepts:** Atomics, memory ordering, lock-free algorithms, compare-and-swap
**Languages:** C (stdatomic), Rust (atomic types), Java (j.u.c.atomic)
**Topics:**
- Atomic operations and compare-and-swap
- Memory ordering (acquire, release, seq_cst)
- Lock-free data structures (stack, queue)
- ABA problem and solutions
- Rust's safety even with atomics
- When lock-free is worth it (rarely!)
- Comparing atomic operations across languages
- Memory fences and barriers

**Lab:** Implement lock-free data structure in C and Rust, compare difficulty and safety

---

### Week 8: Foreign Function Interfaces and Multi-Language Systems
**Concepts:** FFI, calling conventions, marshalling, binding generation
**Languages:** C (core library), Python (ctypes/cffi), Ruby (FFI), Haskell (FFI), Rust (FFI)
**Topics:**
- C as lingua franca for FFI
- Calling C from Python (ctypes, cffi)
- Calling C from Ruby, Haskell, Rust
- Type marshalling and conversion
- Memory safety across language boundaries
- Performance implications of FFI
- Automatically generating bindings
- Real-world multi-language architectures

**Lab:** Create C library, call it from Python, Ruby, and Haskell - build multi-language system

---

### Week 9: Domain-Specific Languages
**Concepts:** Internal vs external DSLs, DSL design, language-oriented programming
**Languages:** Racket (ideal for DSLs), Ruby (internal DSLs), Haskell (EDSLs), Prolog (logic DSLs)
**Topics:**
- When to build a DSL vs library
- Internal DSLs using host language features
- Ruby's DSL capabilities (Rails, RSpec as examples)
- External DSL implementation (using parser from Week 3-4)
- Haskell embedded DSLs
- Racket's #lang for creating languages
- Prolog as a DSL for logic problems
- DSL design principles

**Lab:** Design and implement DSL in Racket (full language) and Ruby (internal DSL), compare approaches

---

### Week 10: Production Systems and Real-World Integration
**Concepts:** Build systems, testing, deployment, debugging across languages
**Languages:** All 9 languages - using appropriate tool for each component
**Topics:**
- Package managers across all languages
- Build systems (Make, Cargo, npm, Maven, cabal, raco, etc.)
- Testing frameworks in all languages
- Property-based testing (QuickCheck in Haskell, Hypothesis in Python)
- Documentation generation per language
- Debugging tools for each language
- Continuous integration for multi-language projects
- Deployment considerations
- Real-world language choice case studies

**Lab:** Set up complete CI/CD pipeline for multi-language project

**Final Project:** Substantial software system integrating 4+ languages from different paradigms, demonstrating mastery of all three quarters. Project must include:
- Performance-critical components (C or Rust)
- High-level coordination/scripting (Python or Ruby)
- Type-safe core logic (Haskell)
- UI or concurrent components (JavaScript, Java, or Rust)
- Comprehensive testing in multiple languages
- Build system integrating all components
- Complete documentation

Example Projects:
- **Compiler/Interpreter:** Haskell parser & type checker, C runtime, Python tooling, JavaScript REPL
- **Web Application:** Rust HTTP server, Haskell business logic, JavaScript frontend, Python deployment scripts
- **Data Processing Pipeline:** Haskell transformations, C performance kernels, Python orchestration, Prolog rules engine
- **Distributed System:** Java/Rust services, Python glue code, JavaScript dashboard, Haskell core algorithms
- **Game Engine:** C/Rust core, Python scripting, Haskell game logic, JavaScript editor

Students present their projects, explaining language and paradigm choices.

---

## Assessment

- **Weekly Labs (30%):** Advanced implementations
- **Mini Projects (30%):** Compiler, concurrent system, performance optimization
- **Final Project (35%):** Substantial multi-language system
- **Participation (5%):** Design reviews, architectural discussions

---

# Cross-Quarter Themes

## Language Progression (Depth Over Breadth)

### Quarter 1: Introduction to 9 Languages
Core languages representing all major paradigms - baseline understanding of concepts in each

**Focus:** "I can write simple programs and understand basic concepts in each language"

### Quarter 2: Deepening Understanding in Same 9 Languages
Advanced features and idiomatic usage - developing fluency

**Focus:** "I write idiomatic code and understand each language's unique strengths"

### Quarter 3: Mastery of Same 9 Languages
Expert-level understanding - building real systems and implementing languages

**Focus:** "I'm fluent in multiple paradigms and can build production systems"

**Key Advantage:** By Quarter 3, students have 30 weeks of experience with the same 9 languages, achieving true depth rather than superficial breadth. With 9 instead of 10 languages, there's more time for deep mastery of each.

## Skill Development Arc

### Quarter 1: Understanding and Exposure
- **Reading:** Read and understand code in all 9 languages
- **Writing:** Write simple, correct programs
- **Conceptual:** Translate concepts between languages, recognize paradigm differences
- **Comfort Level:** "I can use any of these languages with documentation"

### Quarter 2: Fluency and Idioms
- **Reading:** Recognize idiomatic code vs anti-patterns
- **Writing:** Write idiomatic code in each language
- **Conceptual:** Choose appropriate paradigms for problems, apply patterns correctly
- **Comfort Level:** "I write code that looks native to each language"

### Quarter 3: Mastery and Creation
- **Reading:** Read and understand language implementations
- **Writing:** Build production systems, create new languages
- **Conceptual:** Deep understanding of tradeoffs, can teach others
- **Comfort Level:** "I'm an expert in multiple paradigms and can contribute to any codebase"

### Depth Trajectory by Language Category

**Functional (Haskell, Racket):**
- Q1: Basic functions, recursion, pattern matching
- Q2: Monads, type classes (Haskell), macros (Racket), lazy evaluation, advanced types
- Q3: Implement type systems (Haskell), build compilers, create languages (Racket), expert-level functional design

**OOP (Java, Ruby, Python):**
- Q1: Classes, objects, inheritance
- Q2: Design patterns, metaprogramming, advanced OOP
- Q3: Large-scale architecture, multi-language integration, framework design

**Systems (C, Rust):**
- Q1: Basic syntax, manual memory, compilation
- Q2: Advanced memory management, concurrency, performance
- Q3: Systems programming, FFI, low-level optimization, production systems

**Logic (Prolog):**
- Q1: Facts, rules, queries, basic unification
- Q2: Advanced logic programming, constraint solving
- Q3: Logic-based DSLs, integration with other paradigms

**Web (JavaScript):**
- Q1: Basic syntax, DOM, async basics
- Q2: Advanced async patterns, functional JavaScript, Node.js
- Q3: Full-stack systems, build tools, integration

## Project Complexity

### Quarter 1: Single-Language, Concept-Focused
- Programs: 50-200 lines
- Structure: Single file or simple multi-file
- Focus: Correctness, understanding concepts
- Examples: FizzBuzz, recursive algorithms, simple data structures
- Assessment: Does it work? Do they understand why?

### Quarter 2: Multi-Language, System-Focused
- Programs: 200-1000 lines
- Structure: Multi-file, 2-3 languages integrated
- Focus: Idiomatic code, appropriate paradigm choice, architecture
- Examples: Web scraper, concurrent server, data pipeline
- Assessment: Is it idiomatic? Good design? Right tool choice?

### Quarter 3: Production-Quality, Multi-Paradigm Systems
- Programs: 1000+ lines
- Structure: Complex multi-language system, 4+ languages
- Focus: Performance, correctness, maintainability, real-world concerns
- Examples: Compiler/interpreter, distributed system, game engine
- Assessment: Production quality? Demonstrates mastery? Deep understanding of tradeoffs?

---

# Prerequisites and Placement

## Entering Quarter 1
- No programming experience required
- Basic computer literacy
- Mathematical thinking helpful but not required

## Entering Quarter 2
- Quarter 1 or equivalent
- Comfortable with at least 2 programming languages
- Understanding of basic data structures and algorithms
- Can implement recursive functions

## Entering Quarter 3
- Quarter 2 or equivalent
- Strong understanding of at least one paradigm
- Experience with concurrent programming
- Can design multi-component systems

---

# Suggested Supplementary Topics

## Workshops (Optional)
- Git and version control
- Debugging techniques across languages
- Development environments and tooling
- Technical writing and documentation
- Code review best practices
- Open source contribution

## Guest Lectures
- Language designers discussing design decisions
- Industry practitioners on real-world language choices
- PL researchers on cutting-edge topics

---

# Learning Resources

## Required Texts (Spanning All Quarters)
- **"Structure and Interpretation of Computer Programs" (SICP)** - Abelson & Sussman
  - Use throughout all quarters for Racket/Scheme
  - One of the best CS books ever written
- **"Learn You a Haskell for Great Good!"** - Miran Lipovaƒça
  - Q1-Q2 for learning Haskell
- **"The Rust Programming Language"** - Official Rust book
  - Q1-Q3, increasingly advanced topics
- **"Crafting Interpreters"** - Robert Nystrom
  - Q3 for language implementation

## Recommended Texts by Quarter

**Quarter 1:**
- "Real World OCaml" - Hickey, Madhavapeddy, Minsky
- "Eloquent JavaScript" - Marijn Haverbeke
- "Think Python" - Allen Downey

**Quarter 2:**
- "Functional Programming in OCaml" - Clarkson et al.
- "Design Patterns" - Gang of Four (to understand what functional programming makes unnecessary)
- "Seven Concurrency Models in Seven Weeks" - Paul Butcher

**Quarter 3:**
- "Types and Programming Languages" - Benjamin Pierce
- "Programming Language Pragmatics" - Michael Scott
- "Systems Programming" - Jim Blandy (Rust focus)

## Online Resources
- Language documentation for all languages
- Exercism.io for practice in multiple languages
- Project Euler for algorithmic challenges
- Rosetta Code for language comparisons

---

# Career Pathways

This sequence prepares students for:

- **Software Engineering:** Ability to quickly learn new languages and frameworks
- **Systems Programming:** Deep understanding of memory, performance, concurrency
- **Programming Language Research:** Foundation in type theory, semantics, implementation
- **Technical Leadership:** Informed decision-making about language and architecture choices
- **Full-Stack Development:** Comfort with languages across the stack
- **Specialized Domains:** Finance (OCaml), Data Science (Python), Web (JavaScript), Systems (Rust)

---

# Assessment Philosophy

## Emphasizes
- Understanding over memorization
- Comparison and analysis
- Design decisions and tradeoffs
- Clear technical communication

## De-emphasizes
- Syntax minutiae
- Speed of completion
- Single "correct" solution

## Project-Based Learning
Each quarter culminates in substantial project demonstrating integration of concepts across multiple languages and paradigms.
